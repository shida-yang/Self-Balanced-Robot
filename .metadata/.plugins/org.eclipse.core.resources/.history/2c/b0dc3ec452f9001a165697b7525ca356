/*
 * HC_05_Bluetooth.c
 *
 *  Created on: Sep 17, 2020
 *      Author: syang
 */

// Communicate with the HC-05 Bluetooth module using SCIA
#include "HC_05_Bluetooth.h"

// two receive buffers for Bluetooth
char BT_RX_BUF[2][32];
// two transmit buffers for Bluetooth
char BT_TX_BUF[2][32];

// markers to show which buf is being filled/complete
bool curr_filling_rx_buf, curr_filling_tx_buf;

void HC_05_init(){
    HC_05_GPIO_init();
    HC_05_SCI_init();

    curr_filling_rx_buf = 0;
    curr_filling_tx_buf = 0;
}

void HC_05_read_string(char* data_str){
    // determine which rx buf is completed
    char* completed_rx_buf = BT_RX_BUF[!curr_filling_rx_buf];

    // copy string byte-by-byte
    int i = 0;
    while(completed_rx_buf[i] != '\0'){
        data_str[i] = completed_rx_buf[i];
    }
    // fill in terminating NULL
    data_str[i] = '\0';
}

void HC_05_send_string(char* data_str){
    // determine which tx buf is completed
    char* completed_tx_buf = BT_TX_BUF[!curr_filling_tx_buf];

    // copy string byte-by-byte
    int i = 0;
    while(data_str[i] != '\0'){
        completed_tx_buf[i] = data_str[i];
    }
    // fill in terminating NULL
    completed_tx_buf[i] = '\0';
}

__interrupt void HC_05_RX_ISR(void){
    // determine which rx buf is being filled
    char* filling_rx_buf = BT_RX_BUF[curr_filling_rx_buf];



    // toggle marker
    curr_filling_rx_buf = !curr_filling_rx_buf;
}

__interrupt void HC_05_TX_ISR(void){

}

// GPIO8 = SCITXDA(O)
// GPIO9 = SCIRXDA(I)
// GPIO10 = HC-05 EN (O)
// GPIO11 = HC-05 STATE (I)
static void HC_05_GPIO_init(){
    // enable pullups
    GpioCtrlRegs.GPAPUD.bit.GPIO8 = 0;
    GpioCtrlRegs.GPAPUD.bit.GPIO9 = 0;
    GpioCtrlRegs.GPAPUD.bit.GPIO10 = 0;
    GpioCtrlRegs.GPAPUD.bit.GPIO11 = 0;

    // GPIO8 = SCITXDA(O)
    // GPIO9 = SCIRXDA(I)
    GpioCtrlRegs.GPAGMUX1.bit.GPIO8 = 1;
    GpioCtrlRegs.GPAGMUX1.bit.GPIO9 = 1;
    GpioCtrlRegs.GPAMUX1.bit.GPIO8 = 2;
    GpioCtrlRegs.GPAMUX1.bit.GPIO9 = 2;

    // asynch qual
    GpioCtrlRegs.GPAQSEL1.bit.GPIO9 = 3;
    GpioCtrlRegs.GPAQSEL1.bit.GPIO11 = 3;

    // direction of EN and STATE
    GpioCtrlRegs.GPADIR.bit.GPIO10 = 1;
    GpioCtrlRegs.GPADIR.bit.GPIO11 = 0;
}

static void HC_05_SCI_init(){
    SciaRegs.SCICTL1.bit.SWRESET = 0;

    // set BAUD rate to 9600 (doc page 2184)
    SciaRegs.SCILBAUD.all = 650 & 0xFF;
    SciaRegs.SCIHBAUD.all = 650 >> 8;

    // 8 data bit, 1 stop bit, no parity
    SciaRegs.SCICCR.bit.SCICHAR = 7;
    SciaRegs.SCICCR.bit.STOPBITS = 0;
    SciaRegs.SCICCR.bit.PARITYENA = 0;

    // allow SCI to complete current transfer if hits breakpoint
    SciaRegs.SCIPRI.bit.FREESOFT = 1;

    // enable receive interrupt
    SciaRegs.SCICTL2.bit.RXBKINTENA = 1;
    Interrupt_register(INT_SCIA_RX, &HC_05_RX_ISR);
    Interrupt_enable(INT_SCIA_RX);

    // enable transmit interrupt
    SciaRegs.SCICTL2.bit.TXINTENA = 1;
    Interrupt_register(INT_SCIA_TX, &HC_05_TX_ISR);
    Interrupt_enable(INT_SCIA_TX);

    // enable TX and RX
    SciaRegs.SCICTL1.bit.TXENA = 1;
    SciaRegs.SCICTL1.bit.RXENA = 1;

    // end software reset
    SciaRegs.SCICTL1.bit.SWRESET = 1;
}

static char HC_05_read_byte(){
    return SciaRegs.SCIRXBUF.all;
}

static void HC_05_send_byte(char data){
    SciaRegs.SCITXBUF.all = data;
}
